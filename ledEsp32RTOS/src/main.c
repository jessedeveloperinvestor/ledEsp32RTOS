//////////////////////////////////////////////////////////////////////////////
//                            HION TECNOLOGIA                               //
//                          PROJETO BMS - KINDER                            //
//                                                                          //
//                         Software Teste SLEEP ESP32                       //
//////////////////////////////////////////////////////////////////////////////
//    Modulo:               DEV KIT ESP                                     //
// Descrição:                                                               //
//   Este software sera a base para o teste da fubnção sleep awake da esp   //
//   Autor:                    Jesse                                        //
//                                                                          //
// Compilador/Assembler:        Visual studio Code Version: 1.44            //
//                              Node.js: 10.16.3                            //
//                              PlatformIO Home:3.1.1 Core 4.3.1            //
//                              Espressif_IDF-ESP32 (4.0.0)                 //
//                                                                          //
// Hardware:            ESP32 DEvKITC                                       //
//                                                                          //
// Data: <11/07/2022>                                                       //
// Historico:                    Iniciais               Motivo da Mudança   //
//                            do Projetista                                 //
//                                                                          //
// 15/07/2022                        JAL               stable  (ESP-IDF 4.0)//
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//     1.      ARQUIVOS DE DEFINIÇÕES (INCLUDES)                            *
//     1.1       Arquivos includes padrões do  Compilador                   *
/////////////////////////////////////////////////////////////////////////////
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

/////////////////////////////////////////////////////////////////////////////
//      1.2   Arquivos includes do ESP-IDF - RTOS                          //
/////////////////////////////////////////////////////////////////////////////

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "freertos/queue.h"
#include "freertos/event_groups.h"
//#include "esp_system.h"
//#include "esp_err.h"
//#include "esp_log.h"
#include "driver/gpio.h"
#include "driver/uart.h"
//#include "driver/can.h"
//#include "driver/ledc.h"
//#include "driver/adc.h"
//#include "driver/i2c.h"
//#include "esp_adc_cal.h"

/////////////////////////////////////////////////////////////////////////////
//      1.3   Arquivos includes de usuário                                 //
/////////////////////////////////////////////////////////////////////////////

    //inserir Aqui

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//      2.      DECLARAÇÕES                                                //
//      2.1       Constantes Internas                                      //
/////////////////////////////////////////////////////////////////////////////

#define DESLIGAR    0                   //COMANDO DESLIGAR  / DESATIVAR
#define LIGAR       1                   //COMANDO LIGAR / ACIONAR
#define TOGGLE      2                   //COMANDO PARA ALTERAR O ESTADO ATUAL
#define BUF_SIZE    500                 //Alocacao do buffer do uart na RAM

/////////////////////////////////////////////////////////////////////////////
//      2.2   Definições de entradas e saídas                               //
/////////////////////////////////////////////////////////////////////////////
#define TXD_UART1  (GPIO_NUM_1)         //PINO TX UART1 = GPIO1
#define RXD_UART1  (GPIO_NUM_3)         //PINO RX UART1 = GPIO3
#define RTS_UART  (UART_PIN_NO_CHANGE)
#define CTS_UART  (UART_PIN_NO_CHANGE)

#define LED_ESP32 (GPIO_NUM_12)       //PINO LATCH (RCLK) DO ESPANSOR DE OUTPUTS

/////////////////////////////////////////////////////////////////////////////
//      3.   GLOBAIS  TYPEDEF STRUCTs                                      //
/////////////////////////////////////////////////////////////////////////////

//inserir aqui

/////////////////////////////////////////////////////////////////////////////
//      3.1   Variáveis Globais  (Valores Default da Aplicação)
/////////////////////////////////////////////////////////////////////////////

//inserir aqui

/////////////////////////////////////////////////////////////////////////////
//      3.1   Variáveis Globais  (Valores Default da Aplicação)
/////////////////////////////////////////////////////////////////////////////
//inserir aqui

/////////////////////////////////////////////////////////////////////////////
// RTOS Task Handles
/////////////////////////////////////////////////////////////////////////////
  //inserir Aqui

/////////////////////////////////////////////////////////////////////////////
// RTOS Queue Handles
/////////////////////////////////////////////////////////////////////////////
  //inserir Aqui

/////////////////////////////////////////////////////////////////////////////
// RTOS Semaphore Handles
/////////////////////////////////////////////////////////////////////////////
  //inserir Aqui

/////////////////////////////////////////////////////////////////////////////
//      3.2.   INTERRUPÇÕES                                                //
/////////////////////////////////////////////////////////////////////////////
  //inserir Aqui

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//      4.   PROTOTIPOS TAREFAS E FUNCOES                                  //
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//                   Nome da função: uart_task(void *arg)
//
// Proposito: Realiza monitoramento e a atuação na UART 1 e 2
//
//   Entrada: void *arg
//     Saída: NULL
/////////////////////////////////////////////////////////////////////////////
void uart_task(void *arg) {
    // Configure a temporary buffer for the incoming data
    uint8_t *data = (uint8_t *) malloc(BUF_SIZE);
    
    while(1) {
        int RxUART1 = uart_read_bytes(UART_NUM_1, data, BUF_SIZE, 1 / portTICK_RATE_MS);
        char *inputCli = "Jesse";
        if (data[0] == inputCli[0] && data[1] == inputCli[1] && data[2] == inputCli[2] && data[3] == inputCli[3] && data[4] == inputCli[4]) {
            uint8_t led = DESLIGAR;
            for (uint8_t i = 0; i < 10; i++) {
                vTaskDelay(500 / portTICK_PERIOD_MS);

                led = !led;
                gpio_set_level(LED_ESP32, led);
            }
        } else {
            uart_write_bytes(UART_NUM_1, data, RxUART1);
        }

        //Exemplo de como mandar um dado para o terminal sem usar PRINTF ///////////////
        uart_write_bytes (UART_NUM_1, "\r\n", 2);   //Final do Frame
        ///////////////////////////////////////////////////////////////////////////////

        vTaskDelay(4000 / portTICK_PERIOD_MS);
    }
} //Final da TASK uart_task
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//                   Nome da função: xLED(void *arg)
//
// Proposito: Piscar LED para teste da ESP32
//
//   Entrada: void *arg
//     Saída: NULL
/////////////////////////////////////////////////////////////////////////////
void xLED(void *arg) {

    uint8_t led = DESLIGAR;

    while(1) {
        vTaskDelay(500 / portTICK_PERIOD_MS);

        led = !led;
        gpio_set_level(LED_ESP32, led);
    }
} //Final da TASK uart_task
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//      5.      FUNÇÃO PRINCIPAL                                           //
/////////////////////////////////////////////////////////////////////////////
void app_main() {

/////////////////////////////////////////////////////////////////////////////
//     Declaração de variáveis locais
/////////////////////////////////////////////////////////////////////////////
    //inserir aqui

/////////////////////////////////////////////////////////////////////////////
//        Definição dos valores Iniciais dos pinos do MCU
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//        Configuracao Inicial dos PERIFERICOS
/////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////
    //GPIO
    gpio_config_t io_conf;                      //Ponteiro de configuração dos pinos
    io_conf.intr_type = GPIO_PIN_INTR_DISABLE;  //Desabilita Interrupçoes
    io_conf.mode = GPIO_MODE_OUTPUT;            //set as output mode
    //io_conf.pin_bit_mask = ((1ULL<<WAKEUP_ISO)   | (1ULL<<SHIFT_LATCH) |
    //                        (1ULL<<SHIFT_CLOCK)  | (1ULL<<SHIFT_DATA)  );    //Defini pinos de saída
    io_conf.pin_bit_mask = (1ULL<<LED_ESP32);
    io_conf.pull_down_en = 0;                   //Desabilita modo PULL-DOWN
    io_conf.pull_up_en = 0;                     //Desabilita modo PULL-UP
    gpio_config(&io_conf);                      //Configura GPIO com as configurações para OUTPUT  
    /////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////    
    // UART1
    uart_config_t uart1_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };
    //UART0
    uart_param_config(UART_NUM_1, &uart1_config);
    uart_set_pin(UART_NUM_1, TXD_UART1, RXD_UART1, RTS_UART, CTS_UART);
    uart_driver_install(UART_NUM_1, BUF_SIZE * 2, 0, 0, NULL, 0);
    ///////////////////////////////////////////////////////////////////////////// 

/////////////////////////////////////////////////////////////////////////////
//      Criação da QUEUE's do RTOS
///////////////////////////////////////////////////////////////////////////// 
    //AFE_queue = xQueueCreate(10, sizeof( struct AFE_Resp ));   //Cria Queue para Mensagem Resposta AFE

/////////////////////////////////////////////////////////////////////////////
//      Criação da Semáforos do RTOS
/////////////////////////////////////////////////////////////////////////////
    //semaforoAFE = xSemaphoreCreateBinary();

/////////////////////////////////////////////////////////////////////////////
//  Configurações iniciais do microcontrolador e criação das TASKs dp RTOS
/////////////////////////////////////////////////////////////////////////////
    //Tarefas do MCU 0 - Primeiro CORE de processamento
    xTaskCreatePinnedToCore(uart_task, "uart_task", BUF_SIZE * 2, NULL, 10, NULL,0);//Tarefa 1 com prioridade (10) no core 0
    // xTaskCreatePinnedToCore(xLED, "xLED", configMINIMAL_STACK_SIZE, NULL, 9, NULL,0);//Tarefa 2 com prioridade (9) no core 0

    //Tarefas do MCU 1 - Segundo CORE de processamento
    //xTaskCreatePinnedToCore(coulombCounter_task, "coulombCounter_task", 4096, NULL, 10, &xHandle_COULOMB,1);//Tarefa -1 com prioridade (10) no core 1

/////////////////////////////////////////////////////////////////////////////
//      Suspensão de Tarefas que não serão utilizadas no inicio da aplicação
///////////////////////////////////////////////////////////////////////////// 
   //inserir aqui

/////////////////////////////////////////////////////////////////////////////
//      Habilita as interrupções do MCU
///////////////////////////////////////////////////////////////////////////// 
   //inserir aqui

/////////////////////////////////////////////////////////////////////////////
//      Inicialização das variáveis da MAIN
/////////////////////////////////////////////////////////////////////////////
   //inserir aqui

/////////////////////////////////////////////////////////////////////////////
//     Loop principal
/////////////////////////////////////////////////////////////////////////////

    //while(1);
}   //FINAL DA FUNCAO PRINCIPAL
/////////////////////////////////////////////////////////////////////////////
//                             FIM DO ARQUIVO                              //
/////////////////////////////////////////////////////////////////////////////